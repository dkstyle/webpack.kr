"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9317],{9317:function(e,a,n){n.r(a),n(7378);var t=n(2682);function p(){return p=Object.assign?Object.assign.bind():function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},p.apply(this,arguments)}function r(e){let{components:a,...n}=e;return(0,t.kt)("wrapper",p({components:a},n),(0,t.kt)("p",null,"컴파일 절차를 커스터마이즈 하기 위해 다양한 인터페이스를 사용할 수 있습니다.\n인터페이스 간에 겹치는 기능도 존재합니다.\n예를 들면, 구성 옵션은 CLI 플래그를 통해 사용할 수 있지만 다른 옵션은 단일 인터페이스를 통해서만 존재합니다.\n아래의 정보가 시작하는 데 도움을 줄 것입니다."),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"cli",parentName:"h2"}),"CLI",(0,t.kt)("a",{href:"#cli","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"명령 줄 인터페이스(CLI)는 빌드를 구성하고 상호작용하는 데 사용됩니다.\n특히 초기 프로토타이핑이나 프로파일링의 경우 유용합니다.\n대부분의 경우 CLI는 설정 파일과 ",(0,t.kt)("inlineCode",{parentName:"p"},"--env")," 같은 몇 가지 플래그를 사용하여 프로세스를 시작하는 데 사용됩니다."),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/cli",parentName:"p"},"CLI에 대해 더 알아보세요!")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"module",parentName:"h2"}),"Module",(0,t.kt)("a",{href:"#module","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"webpack을 사용하여 모듈을 처리할 때 ",(0,t.kt)("a",{href:"/api/module-methods",parentName:"p"},"메소드"),"나 ",(0,t.kt)("a",{href:"/api/module-variables",parentName:"p"},"변수"),"같이 다양한 지원되는 모듈 구문을 이해하는 것이 중요합니다."),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/module-methods",parentName:"p"},"모듈에 대해 더 알아보세요!")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"node",parentName:"h2"}),"Node",(0,t.kt)("a",{href:"#node","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"대부분의 사용자는 설정 파일과 CLI를 함께 사용하는 것만으로도 충분하지만, Node 인터페이스를 통해 컴파일을 보다 세밀하게 제어할 수 있습니다.\n여기에는 다중 설정 전달과 프로그래밍 방식으로 실행 또는 감시, 통계 수집이 포함됩니다."),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/node",parentName:"p"},"Node API에 대해 더 알아보세요!")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"loaders",parentName:"h2"}),"Loaders",(0,t.kt)("a",{href:"#loaders","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"로더는 모듈의 소스 코드에 적용되는 변환입니다.\n소스 코드를 매개 변수로 받고 변환이 적용된 해당 코드의 새 버전을 반환하는 함수로 작성됩니다."),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/loaders",parentName:"p"},"로더에 대해 더 알아보세요!")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"plugins",parentName:"h2"}),"Plugins",(0,t.kt)("a",{href:"#plugins","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"플러그인 인터페이스를 통해 컴파일 프로세스에 직접 접근할 수 있습니다.\n플러그인은 컴파일 동안 서로 다른 지점에서 실행되는 수명주기 훅에 핸들러를 등록할 수 있습니다.\n각각의 훅이 실행될 때 플러그인은 현재 컴파일 상태에 대한 모든 액세스 권한을 갖습니다."),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/plugins",parentName:"p"},"플러그인에 대해 더 알아보세요!")))}r.isMDXComponent=!0,a.default=r}}]);