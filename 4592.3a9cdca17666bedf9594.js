"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4592],{4592:function(e,a,t){t.r(a),t(7378);var n=t(2682);function p(){return p=Object.assign?Object.assign.bind():function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},p.apply(this,arguments)}function l(e){let{components:a,...t}=e;return(0,n.kt)("wrapper",p({components:a},t),(0,n.kt)("p",null,"코어 저장소에 기여할 때나, 로더 또는 플러그인을 작성할 때, 아니면 복잡한 프로젝트를 작업할 때도 디버깅 도구가 워크 플로에서 중심이 될 수 있습니다. 규모가 큰 프로젝트에서의 느린 성능이나 도움이 되지 않는 트레이스백이 문제라면, 다음의 유틸리티를 사용하여 문제를 보다 수월하게 파악할 수 있습니다."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{href:"/api/node/#stats-object",parentName:"li"},"Node"),"와 ",(0,n.kt)("a",{href:"/api/cli/#common-options",parentName:"li"},"CLI"),"를 통해 제공되는 ",(0,n.kt)("a",{href:"/api/stats",parentName:"li"},(0,n.kt)("inlineCode",{parentName:"a"},"stats")," 데이터"),"."),(0,n.kt)("li",{parentName:"ul"},"최신 Node.js 버전 및 ",(0,n.kt)("inlineCode",{parentName:"li"},"node-nightly"),"으로 사용하는 Chrome ",(0,n.kt)("strong",{parentName:"li"},"DevTools"),".")),(0,n.kt)("h2",null,(0,n.kt)("span",{id:"stats",parentName:"h2"}),"Stats",(0,n.kt)("a",{href:"#stats","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,(0,n.kt)("a",{href:"/api/stats",parentName:"p"},"이 데이터"),"를 수동으로 조사하거나, 도구를 사용하여 데이터를 처리할 때도 ",(0,n.kt)("inlineCode",{parentName:"p"},"stats")," 데이터는 빌드 이슈 디버깅에 매우 유용할 수 있습니다. 이 내용을 설명하는 ",(0,n.kt)("a",{href:"/api/stats",parentName:"p"},"페이지"),"가 있으므로 여기서 자세히 설명하지는 않지만, 다음 정보를 찾는 데 사용할 수 있습니다."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"모든 모듈의 내용."),(0,n.kt)("li",{parentName:"ul"},"모든 청크에 포함된 모듈."),(0,n.kt)("li",{parentName:"ul"},"모듈 별 컴파일 및 통계 분석."),(0,n.kt)("li",{parentName:"ul"},"빌드 오류 및 경고."),(0,n.kt)("li",{parentName:"ul"},"모듈 간의 관계."),(0,n.kt)("li",{parentName:"ul"},"그리고 더 많은 것들..")),(0,n.kt)("p",null,"또한 공식 ",(0,n.kt)("a",{href:"https://github.com/webpack/analyse",parentName:"p"},"분석 도구")," 및 ",(0,n.kt)("a",{href:"/guides/code-splitting/#bundle-analysis",parentName:"p"},"다양한 도구"),"가 이 데이터를 분석하고 여러 방법으로 시각화합니다."),(0,n.kt)("h2",null,(0,n.kt)("span",{id:"devtools",parentName:"h2"}),"DevTools",(0,n.kt)("a",{href:"#devtools","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,(0,n.kt)("a",{href:"https://nodejs.org/api/console.html",parentName:"p"},(0,n.kt)("inlineCode",{parentName:"a"},"console"))," 문은 간단한 시나리오에서는 잘 작동하지만 때로는 더 강력한 솔루션이 필요합니다. 대부분의 프런트엔드 개발자가 이미 알고 있듯이 Chrome DevTools는 웹 애플리케이션을 디버깅할 때 생명의 은인 같은 역할을 합니다. ",(0,n.kt)("em",{parentName:"p"},"하지만 거기서 멈추지 않고 더 나아갈 수 있습니다"),". Node v6.3.0+부터 개발자는 내장된 ",(0,n.kt)("inlineCode",{parentName:"p"},"--inspect")," 플래그를 사용하여 DevTools에서 Node 프로그램을 디버깅할 수 있습니다."),(0,n.kt)("p",null,"이를 통해 중단점을 쉽게 생성하고, 메모리 사용을 디버그 하며, 콘솔에서 객체를 노출하여 검사하는 등, 여러 작업을 수행할 수 있습니다. 이 짧은 데모에서는 가장 최신의, 가장 훌륭한 검사 기능을 사용 가능하게 하는 [",(0,n.kt)("inlineCode",{parentName:"p"},"node-nightly"),"] (",(0,n.kt)("a",{href:"https://github.com/hemanth/node-nightly",parentName:"p"},"https://github.com/hemanth/node-nightly"),") 패키지를 활용합니다."),(0,n.kt)("aside",{className:"warning"},(0,n.kt)("h6",{className:"warning__prefix",parentName:"aside"},"warning"),(0,n.kt)("p",{parentName:"aside"},(0,n.kt)("inlineCode",{parentName:"p"},"--inspect")," 인터페이스는 v6.3.0부터 사용할 수 있으므로 로컬 버전에서 사용해보세요. 하지만 특정 기능과 플래그는 데모에 보이는 것과 다를 수 있습니다.")),(0,n.kt)("p",null,"패키지를 전역으로 설치하여 시작해보세요."),(0,n.kt)("pre",null,(0,n.kt)("code",{className:"hljs language-bash",parentName:"pre"},(0,n.kt)("span",{className:"token function",parentName:"code"},"npm")," ",(0,n.kt)("span",{className:"token function",parentName:"code"},"install")," --global node-nightly")),(0,n.kt)("p",null,"이제 설치를 완료하려면 한 번 실행해야 합니다."),(0,n.kt)("pre",null,(0,n.kt)("code",{className:"hljs language-bash",parentName:"pre"},"node-nightly")),(0,n.kt)("p",null,"이제 ",(0,n.kt)("inlineCode",{parentName:"p"},"--inspect")," 플래그로 간단하게 ",(0,n.kt)("inlineCode",{parentName:"p"},"node-nightly"),"를 사용하여 webpack 기반 프로젝트에서 빌드를 시작할 수 있습니다. 참고로, ",(0,n.kt)("inlineCode",{parentName:"p"},"npm run build"),"과 같은 NPM ",(0,n.kt)("inlineCode",{parentName:"p"},"scripts"),"를 실행할 수 없으므로 전체 ",(0,n.kt)("inlineCode",{parentName:"p"},"node_modules")," 경로를 지정해야 합니다."),(0,n.kt)("pre",null,(0,n.kt)("code",{className:"hljs language-bash",parentName:"pre"},"node-nightly --inspect ./node_modules/webpack/bin/webpack.js")),(0,n.kt)("p",null,"이는 다음과 같이 출력될 것입니다."),(0,n.kt)("pre",null,(0,n.kt)("code",{className:"hljs language-bash",parentName:"pre"},"Debugger listening on ws://127.0.0.1:9229/c624201a-250f-416e-a018-300bbec7be2c\nFor ",(0,n.kt)("span",{className:"token builtin class-name",parentName:"code"},"help")," see https://nodejs.org/en/docs/inspector")),(0,n.kt)("p",null,"이제 브라우저에서 ",(0,n.kt)("inlineCode",{parentName:"p"},"chrome://inspect"),"로 이동하면 ",(0,n.kt)("em",{parentName:"p"},"Remote Target"),' 헤더 내에 검사 한 활성 스크립트가 표시됩니다. 각 스크립트 하단의 "inspect" 링크를 클릭하여 전용 디버거를 열거나 ',(0,n.kt)("em",{parentName:"p"},"Open dedicated DevTools for Node")," 링크를 클릭하여 자동으로 연결되는 세션을 시작할 수 있습니다. 매번 DevTools 탭을 자동으로 여는 편리한 Chrome 플러그인인 ",(0,n.kt)("a",{href:"https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj",parentName:"p"},"NiM 확장 프로그램"),"도 확인해 보세요. 스크립트를 ",(0,n.kt)("inlineCode",{parentName:"p"},"--inspect"),"할 때마다 DevTools 탭을 자동으로 실행하는 유용한 크롬 플러그인입니다."),(0,n.kt)("p",null,"스크립트의 첫 번째 문에서 중단하는 ",(0,n.kt)("inlineCode",{parentName:"p"},"--inspect-brk")," 플래그 사용을 추천합니다. 이를 통해 소스를 확인하여 중단점을 설정하고, 원하는 대로 빌드를 시작 또는 중지할 수 있습니다. 또한 여전히 스크립트에 인수를 전달할 수 있다는 점을 잊지 마세요. 예를 들어 설정 파일이 여러 개인 경우",(0,n.kt)("inlineCode",{parentName:"p"},"--config webpack.prod.js"),"를 전달하여 디버깅할 설정을 지정할 수 있습니다."))}l.isMDXComponent=!0,a.default=l}}]);